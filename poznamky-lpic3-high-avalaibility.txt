*** Poznamky k priprave na LPIC3-High Availability ***

Ako na linuxe vypnut PC-speaker: #rmmod pcspkr

- dobra stranka na zaciatocnu konfiguraciu znamych distribucii:

https://www.server-world.info/en/note?os=Ubuntu_20.04&p=initial_conf&f=3

- ^^^ nevedno do kedy bude online a chyba tam IPv6 :-/

- nastavenie siete v systeme Debian11:
 - edituje sa /etc/network/interfaces
 - a potom nieco taketo:

-=-=-=-=-=-=-=-=-
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
allow-hotplug ens33
#iface ens33 inet dhcp
# add static settings
iface ens33 inet static
# IP address
address 192.168.1.242
# network address
network 192.168.1.0
# subnet mask
netmask 255.255.255.0
# broadcast address
broadcast 192.168.1.255
# default gateway
gateway 192.168.1.1
# name server
dns-nameservers 193.17.47.1 185.43.135.1

a nasledne aplikujeme config:
# systemctl restart ifup@ens33 

Dodatok k nastaveniu statickej IPv6 addr.:
 - bolo potrebne do suboru "/etc/sysctl.conf" vlozit riadky:

net.ipv6.conf.ens37.autoconf = 0
net.ipv6.conf.ens37.accept_ra = 0

 - ulozit, nasledne treba reboot alebo prikaz: # sysctl -p

Nasledne do suboru /etc/network/interfaces pridat riadky napr.:

# The secondary network interface
auto ens37
allow-hotplug ens37
iface ens37 inet6 static
    address 2001:db8:cafe::242/64
    gateway 2001:db8:cafe::42
    dns-nameservers 2001:db8:7ea::1 2001:db8:7ea::2
-=-=-=-=-=-=-=-=-

- nastavenie siete na CentOS:

- pouzil som nejake hanbate GNOME GUI, neviem preco sa to hned neaplikovalo

- nastavenie siete na Fedora 35 Server:

- pouzil som cli nastroj "nmcli" z balika "NetworkManager"
	
- syntax je takto nejako:

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	 
# if you did not set HostName, set it like follows

[root@localhost ~]# hostnamectl set-hostname dlp.srv.world

# display devices

[root@localhost ~]# nmcli device

DEVICE  TYPE      STATE      CONNECTION
ens33  ethernet  connected  ens33
lo      loopback  unmanaged  --

# set IPv4 address

[root@localhost ~]# nmcli connection modify ens33 ipv4.addresses 10.0.0.30/24

# set default gateway

[root@localhost ~]# nmcli connection modify ens33 ipv4.gateway 10.0.0.1

# set DNS

# if set multiple DNS, specify with space separated ipv4.dns "10.0.0.10 10.0.0.11 10.0.0.12"

[root@localhost ~]# nmcli connection modify ens33 ipv4.dns 10.0.0.10

# set DNS search base (your domain name)

[root@localhost ~]# nmcli connection modify ens33 ipv4.dns-search srv.world

# set manual for static setting (it's [auto] for DHCP)

[root@localhost ~]# nmcli connection modify ens33 ipv4.method manual

# restart the interface to reload settings

[root@localhost ~]# nmcli connection down ens33; nmcli connection up ens33 

Nasledne overime config:

# nmcli device show ens33 

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Ako  v unix-like systemoch konvertovat video:

1. nainstalujeme ffmpeg (apt install ffmpeg, yum install ffmpeg, brew install ffmpeg a pod.)

2. podla tohto popisu dame konvertovat:

 Update 2020: This answer was written in 2009. 
 Since 2013 a video format much better than H.264 is widely available, 
 namely H.265 (better in that it compresses more for the same quality, or 
 gives higher quality for the same size). 
 To use it, replace the libx264 codec with libx265, and push the compression lever further 
 by increasing the CRF value â€” add, say, 4 or 6, since
 a reasonable range for H.265 may be 24 to 30. Note that lower CRF values correspond to 
 higher bitrates, and hence produce higher quality videos.

 $ ffmpeg -i input.mp4 -vcodec libx265 -crf 28 output.mp4

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Ako v Ubuntu 20.04 konfigurovat siet:

Treba "vypnut" povodny config file:

# mv /etc/netplan/00-installer-config.yaml /etc/netplan/00-installer-config.yaml.disabled

Treba vytvorit novy config file:

# vim /etc/netplan/00-installer-config.yaml

A nasledne pridat nieco taketo:

network:
  ethernets:
    # interface name
    ens33:
      dhcp4: no
      # IP address/subnet mask
      addresses: [192.168.1.244/24]
      # default gateway
      gateway4: 192.168.1.1
      nameservers:
        # name server to bind
        addresses: [193.17.47.1, 185.43.135.1]
      dhcp6: yes
  version: 2

Ulozit subor a potom zadat (prikaz spravi aj syntax check):

# netplan try

alebo:

# netplan apply

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Sprava diskov:

Prikaz vypise blokove zariadenia: # lsblk
Prikaz vypise UUID aktivnych particii: # blkid
Prikaz vytvori Ext4 particiu: # mkfs.ext4 /dev/sdb1

Ako vytvorit Swap subor, nie particiu: 

Prikaz vypise stav Swap-u:
# free -m

# dd if=/dev/zero of=swap_file bs=1024k count=pocet_MB
# mkswap swap_file
# swapon swap_file
# swapoff swap_file	<< pozor treba mat nahradnu Swap kapacitu
 
V kontexte Swap-u existuje v kerneli tzv. OOM-killer, ktory pri nedostatku pamate zabija procesy

**Praca s LVM:**
Aktualna verzia LVM2.

Prikaz na interaktivne CLI: # lvm
- nasledne: lvm> help

Prikaz vypise Physical Volumes: pvs
Prikaz detailne vypise Physical Volumes: pvdisplay
Prikaz vypise Volume Groups: vgs
Prikaz detailne vypise Volume Groups: vgdispaly
Prikaz vipise Logical Volumes: lvs
Prikaz detailne vypise Logical Volumes: lvdisplay

Na pracu s LVM vytvorime jednu alebo viac PV particii na realnych diskoch s cfdisk/fdisk/parted a potom mkfs.XYZ

Prikaz vytvori VG s nazvom "vg-nas" a pouzije prve PV (particiu): # vgcreate vg-nas /dev/sdb1   
- nasledne rozsirime tuto VG (pool) o dalsiu PV particiu: #vgextend vg-nas /dev/sdc1

Prikaz vytvori LV particiu "lvnas1" z danej VG "vg-nas": # lvcreate --size 15g --type linear -n lvnas1 vg-nas 

Prikaz naformatuje LV particu na Ext4-FS: # mkfs.ext4 /dev/mapper/vg--nas-lvnas1

Prikaz rucne namountuje LV "lvnas1" do adresara "/mnt/lvnas1": # mount /dev/mapper/vg--nas-lvnas1 lvnas1 
Nasledne upravou suboru "/etc/fstab" pridame riadok, ktory zabezpeci mount po boot-e: 
- pomoze prikaz "blkid"

/dev/disk/by-uuid/20067ff2-0599-4fd3-9cfc-dbbd6aa07aec /mnt/lvnas1 ext4 defaults 0 1
/dev/disk/by-uuid/4c1d7f90-0dcb-4ed1-acce-0062c2c8c186 /mnt/lvnas2 ext4 defaults 0 1

Potom si uz napr. v $HOME mozeme vytvorit link na svoju NAS particiu: $ ln -s /mnt/lvnas1 nas

Ako ostranit LV z VG: # lvremove vg-nas/lvnas3

Ako zvacsit nejake LV z VG poolu (moze byt mounted): # lvresize -r -L +5g vg-nas/lvnas1
Overime s: df -h /mnt/lvnas1

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
**Praca s inode-ami:**

Prikaz vypise prava a inode informacie o subore: $ stat subor.xyz
- da sa pouzit aj prikaz:  $ ls -li

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Ako pridat uzivatela do dalsej group: # usermod -a -G examplegroup exampleusername

Ako zmenit vlastnikov na adresary alebo subore: # chown -R root:vgnas /mnt/lvnas1

Ako nastavit prava na subore alebo adresary: # chmod g+w /mnt/lvnas1
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Ako vypisat parametre kernelu, s ktorymi nabootoval: $ cat /proc/cmdline

Ako zistit ake KILL signaly system podporuje: $ kill -l

Dobry nastroj na kontrolu syntaxe BASH skriptov: shellcheck

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Praca s GRUB2:

Ulahcene konfiguracne moznosti su v subore: /etc/default/grub
- da sa precitat manual pre vsetky moznosti: $ info -f grub -n 'Simple configuration' 

Zakladny konfig. subor pre GRUB2, ktory je vygenerovany, nema sa upravovat: /boot/grub/grub.cfg

Skripty, ktore podla poradia generuju konfig. subor GRUB2: $ ls /etc/grub.d/* 

Ako nainstalovat GRUB2 v MBR mode: # grub-install --boot-directory=/mnt/boot /dev/sdc

Ako zistit s akymi parametrami bol nacitany kernel: $ cat /proc/cmdline

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Praca s init systemom "systemd":

Ako vypisat logy pre proces podla urciteho string patternu: $ journalctl --unit=ssh
Ako vypisat status nejakeho spusteneho daemona: $ systemctl status sshd.service
Ako zabezpecit, aby si beziaci proces nacital novy config: # systemctl reload sshd.service
Ako restartovat nejaky proces: # systemctl restart sshd.service
Ako vypisat vsetky systemd unit-y, ktore su nacitane v RAM: # systemctl list-units
 - ako vypisat vsetky unit-y, ktore su nacitane ale neaktivne: # systemctl list-units --all  
Ako vypisat vsetky unit subory pre systemd: # systemctl list-unit-files --all

Ako vyipsat, na com zavisy dany proces a co vyzaduje: 
# systemctl show -p Requires sshd.service
# systemctl show -p Wants sshd.service

Nastroj na spustanie viacerych programov/skriptov v jednom adresary: run-parts(8)
 - v suvislosti so starsim init-om podla "System V Init" 
Ako zistit v akom run-level-y bezi system: $ who -r

V akom adresary sa nachadzaju system V init skripty: $ cd /etc/rc5.d/ 
Ako prepnut rn-level do single-user modu: # telinit -s

Ako restartovat system: # shutdown -r now
 - pripadne za 10 min.: # shutdown -r +10

Ako zabezpecit, aby sa do systemu mohol prihlasit len superuser, vytvorime subor: /etc/nologin 
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Logovanie a diasgnostika user-space nastrojov:

Ako vypisat od zaciatku log z bootovania: $ journalctl -b
 - pripadne v od konca do zaciatku: $ journalctl -b -r
 - pripadne vypisanie logu z predoslych bootov: $ journalctl -b -1
 - overenie, ze dany shutdown/reboot bol cisty: $ journalctl -r -b -1

Ako vypisat vsetky ID jednotlivych boot-ov: $ journalctl --list-boots

Alternativy pre logovanie v Linuxe: syslog-ng (/etc/syslog-ng) a rsyslogd /etc/rsyslog.cfg)
  
Ako vypisat, kto bol kedy bnaposledy prihlaseny: $ lastlog *alebo* $ last

Ako vypisat log pre konkretne Process ID: $ journalctl _PID=XYZ

Ako vypisat log spred 4 hodin: $ journalctl -S -4h
 - dalsi priklad presne zadaneho casu: $ journalctl -S 06:00:00 
 - dalsi priklad presne zadaneho datumu: $ journalctl -S 2022-01-10

Ako vypisat logy pre konkretny proces/program/daemon/unit: $ journalctl -u ssh
 - pripadne prikaz vypise vsetky logovacie unit-y: $ journalctl -F _SYSTEMD_UNIT

Vypisovanie logov podla string match patternu: $ journalctl -g 'kernel.'
 - da sa skombinovat, ked chceme hladat ine logy v case okolo hladaneho stringu s: $ journalctl -S 

Ako vypisat logy podla Severity level: $ journalctl -p 3
 - pripadne s rozsahom: $ journalctl -p 2..3

Ako sledovat real-time priebeh systemoveho logu: $ journalctl -f
 - logy sa daju vypisovat a sledovat napr. aj v json formate: $ journalctl -f -o json-pretty

Ako ulozit urcite logy v text formate: $ journalctl -u ssh -o old > sshd.log
 - ako ulozit rovnaky log napr. vo formate "json": $ journalctl -u ssh -o json > sshd.log.json

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Praca s zivatelskymi uctami:

Ako zmenit default shell uzivatela: $ chsh vlkv -s /bin/bash
 - dany SHELL by mal byt v subore: /etc/shells

Ako zistit s akymi argumentami je spusteny program/daemon: $ ps aux | grep getty

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Ako zabezpecit, aby sa na Ubuntu 20.04 systemovy log neplnil hlaskami:
	
	Apr 26 16:10:29 ubuntu2004 multipathd[728]: sda: add missing path
	Apr 26 16:10:29 ubuntu2004 multipathd[728]: sda: failed to get udev uid: Invalid argument
	Apr 26 16:10:29 ubuntu2004 multipathd[728]: sda: failed to get sysfs uid: Invalid argument
	Apr 26 16:10:29 ubuntu2004 multipathd[728]: sda: failed to get sgio uid: No such file or directory

- obsah suboru sa moze prepisat nasledovne:

$ sudo vim /etc/multipath.conf

tam vlozit: 
---------------------
defaults {
    user_friendly_names yes
}
blacklist {
    devnode "^(ram|raw|loop|fd|md|dm-|sr|scd|st|sda)[0-9]*"
}
---------------------

Po ulozeni, treba restartovat proces multipathd:

$ sudo systemctl restart multipathd.service
 
- dodatocne mozeme skontrolovat stav procesu: $ systemctl status multipathd.service
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Cron a planovanie v kratkosti:

Ako vytvorit cron job, aby sa vystup aj err presmerovali do /dev/null: 10 5 * * * /usr/bin/xyz > /dev/null 2>&1

Ako spustit jednorazovo nejaky prikaz: $ at 15:00
- nasledne do promptu zadame prikaz, ukoncime s Ctrl-d
- naplanovane ulohy si mozeme vypisat s: $ atq
- tretiu ulohu mozeme vymazat s: $ atrm 3

Ako zadat ulohu pre systemd: $ systemd-run --on-calendar='2022-01-12 16:00' /bin/echo testovacie-echo
- tieto docasne (transient) unit-y mozeme vypisat s: $ systemctl list-units | grep timer 

Ako vypisat cron ulohy pre daneho uzivatela: $ crontab -l
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
Praca s monitorovanim procesov:

Ako ovladat program "top":

- medzernik obnovuje stav okamzite
- "M" usporiada procesy podla rezidentnej pamate (case sensitive)
- "T" usporiada podla celkoveho kumulativneho procesoroveho casu
- "P" default nastavenie podla aktualnej CPU zataze
- "u" zobrazi len procesy daneho uzivatela
- "?" zobrazi pomoc s interaktivnymi prikazmi

Dalsie monitorovacie alternativy su: "atop" a "htop"

Ako mozeme vypisat otvorene subory, napr. pre 1 uzivatela: $ lsof | grep vlkv
- vhodne pozriet $ man 8 lsof
- napr. prikaz, ktory vypise otvorene subory, pre dany PID: $ lsof -p 1234
- prikaz vypise otvorene sietove sockety: $ sudo lsof -i
- pripadne bez reverzneho prekladu DNS (da sa filtrovat s grep-om): $ sudo lsof -n -i
- vypisat pouzitie vsetkych suborov v danom adresary: # lsof +D /usr/

Ako mozeme vypisat systemove volania nejakeho programu, napr.: $ strace cat /dev/null
 - na presmerovanie do suboru treba pouzit err redirect: 2>

Ako mozem vypisat nacitane kniznice nejakeho programu: $ man 1 ltrace 
 - da sa pozriet aj program "ldd": $ man 8 ldd

Ako vypisat vsetky vlakna spustenych procesov: $ ps m
 - vypis sa da vylepsit s: $ ps m -o pid,tid,command  

Ako zmerat cas trvania nejakeho spusteneho programu/ulohy: $ time <uloha>
 - priklad: $ time lsof +D /usr/

Ako vypisat strom spustenych procesov: $ ps axjf

Ako vypisat CPU prioritu (tzv. Niceness, stlpec "NI") spustenych procesov: $ ps al
 - vhodne pozriet $ man ps

Ako zmenit CPU prioritu (Niceness, zhovievavost k inym procsesom) daneho procesu: # renice 20 <PID>
 - default hodnota je "0", rozsah je -20 az 20. Hodnota "-20" sa NEDOPORUCUJE.
 - najvyssiu prioritu, teda najnizsiu zhovievavost (NEDOPORUCUJE SA) nastavime s: # renice -20 <PID> 

Ako vypisat stav operacnej pamate: $ free -m
 - je dobre si uvedomit, co je realna spotreba a co je file cashe/buffer

Ako vypisat, ake parametre ma nastaveny kernel a system: $ getconf -a
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca so sietou (IPv4, IPv6, WiFi)*

Ako vypisat sietove rozhrania a ich parametre: $ ip address show
 - prikaz sa da skracovat napr.: $ ip a s

Ako vypisat smerovaciu tabulku systemu: $ ip route show
 - podobne sa da skracovat: $ ip r s
 - smerovacuiu tab. pre IPv6 vypiseme s: $ ip -6 route show

Ako vypisat, akym rozhranim bude smerovany paket s danou cielovou adresou: $ ip route get 9.9.9.9
 - resp. pre ipv6: $ ip -6 route get 2620:fe::9 

Ako nastavit predvolenu branu: # ip route add default via 192.168.100.1
 - predvolenu branu vymazeme s: # ip route del default
 - staticku cestu nastavime s: # ip route add 192.168.16.0/24 via 10.1.2.3
 - staticku cestu vymazeme s: # ip route del 192.168.16.0/24

Ako overit konektivitu sietoveho zariadenia: $ ping 9.9.9.9
 - ekvivalent pre IPv6: $ ping6 2620:fe::9

Ako vypisat vsetky TCP a UDP sockety: $ ss -tupa
 - vhodne pozriet: $ man 8 ss

Ako vypisat reverzny PTR zaznam pre danu IP adresu: $ host 9.9.9.9
 - pre IPv6: $ host 2620:fe::9
 - pripadne detailna diagnostika: $ dig -x 9.9.9.9

Pozriet nastroje NetworkManager a systemd.networkd(5)

Konfiguracne subory, ktore zabezpecuju DNS preklad: /etc/nsswitch.conf , /etc/hosts , /etc/resolv.conf
 - zvycajne vsak konfigurovane s inymi nastrojmi ako Networkmanager alebo Netplan

Ako overit ze na DNS preklady sa pouziva Cache: $ nslookup -debug quad9.net
 - vo vypise vidime riadky: "Server: 127.0.0.53" a "Address: 127.0.0.53#53"

Ako overit nastavenia DNS v systeme: $ resolvectl status

Ako vypisat vsetky sietove sockety v systeme: # netstat -tunap

Cisla TCP/UDP portov sa daju zistit z referencneho .txt suboru: /etc/services

Ako rucne spustit DHCP klienta: # dhclient ens33

Ako overit, ci je v kerneli zapnuty packet routing: $ sysctl net.ipv4.ip_forward
 - smerovanie IPv4 paketov zapneme s: # sysctl -w net.ipv4.ip_forward=1
 - smerovanie IPv6 paketov zapneme s: # sysctl -w net.ipv6.conf.all.forwarding=1
 - perzistentne nastavenie co prezije reboot je v subore: /etc/sysctl.conf
   - do suboru vlozime riadky "net.ipv4.ip_forward=1" alebo/aj "net.ipv6.conf.all.forwarding=1" 
   - zmeny v subore ulozime a aplikujeme s: # sysctl -p

Ako vypisat pravidla firewallu IPtables: $ iptables -L

Ako si vytvorime pravidla firewallu: vytvorime subor /etc/network/iptables.up.rules
 - do suboru mozeme pisat riadky napr.:

*filter
:INPUT ACCEPT [8:631]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [5:576]
-A INPUT -s 192.168.1.242/32 -j DROP
COMMIT

Nasledne aplikujeme zmeny tak, ze ak sa "odrezeme", konfiguracia sa obnovi po 20 sek: # iptables-apply -t 20

Je dobre si uvedomit, ze IPtables su nahradene nastrojom NFtables, vid.: www.netfilter.org/projects/nftables/index.html 

Ako vypisat IPv4 ARP tabulku a zaroven aj IPv6 ND tabulku: $ ip neigh
 - opat sa da skratit na: $ ip n
 - stary prikaz pre IPv4: $ arp -an

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s TCP/UDP aplikaciami, socketmi*

Ako vytvorit testovaci TCP socket co pocuva na danom porte: # nc -l 23
 - na socket sa so vzdialenej stanice pripojime napr.: $ telnet A.B.C.D 23
 - pripadne opat s programom "nc": $ nc A.B.C.D 23

Ako "stopovat" pripojenie programu "curl" k TCP HTTP socketu: $ curl --trace-ascii tracelog.txt http://example.com
 - nasledne si pozrieme zaznam v subore "tracelog.txt"

Ako si vygenerovat PKi par klucov na asymetricke syfrovanie a auth.: $ ssh-keygen -t rsa -N '' -f /home/user1/.ssh/id_rsa
 - podobne pre DSA par klucov: $ ssh-keygen -t dsa -N '' -f /home/user1/.ssh/id_dsa

Pozriet si projekt/program "fail2ban", pripadne "sshguard" alebo "denyhosts".

Ako pomocou protokolu SCP kopirovat z jednej vzdialenej IP na inu vzdialenu IP: $ scp user1@host1:file user2@host2:file

Ako vypisat vsetky TCP sockety, bez bez DNS prekladu adries: # lsof -i -n

Ako vypisat aktivne procesy pre konkretny TCP/UDP port: # lsof -i:22
 - daju sa pouzit aj nazvy protokolov podla suboru "/etc/services", teda: # lsof -i:ssh
 - ked chceme spcifikovat len TCP sockety: # lsof -iTCP:22
 - ked chceme este presnejsie specifikovat pre IPv6: # lsof -i6TCP:22
 - este napr. bez prekladu na PTR DNS: # lsof -n -i6:22
 - vypise aktivne a pocuvajuce UDP "streamy": # lsof -n -iUDP
 - vypise stav pre konkretny protokol:port a IP adresu servera (nie klienta): # lsof -iTCP@192.168.1.240:22

Pozriet si nastroj "tcpdump", velmi vela moznosti.
 - da sa napr. zacat s manualom: $ man tcpdump
 - napr. packet sniffing len ICMP paketov z/na konkretnu IPv4 adresu: # tcpdump -nv icmp and host 192.168.1.240
 - napr. komunikaciu na IPv6 TCP socket na porte 22, pre interface "ens38": # tcpdump -nv -i ens38 ip6 and port 22

Pozriet si nastroj "nmap", velmi vela moznosti.
 - POZOR na legislativne dosledky skenovania sieti, ktore nevlastnim/nespravujem, bez povolenia spravcu/majitela.
 - napr. sa da zacat s manualom: $ man nmap

Ako vypisat lokalne Unix Domain sockety, pre aktualneho uzivatela: $ lsof -U
 - vypisanie vsetkych Unix Domain socketov (ako root): # lsof -U

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s BASH skriptami*

Ako zabezpecit, aby sa skript spustal aj na inych systemoch (portability), skript zacina s: #!/usr/bin/env bash
 - nevyhoda je, ze skript je spustany s prvym najdenym interpretom (BASH, Python, etc.)

V BASHi sa rozlisuje "Quoting" alebo 'Literals'.
 - teda je rozdiel v prikaze: $ echo "$100" ... a v prikaze: $ echo '$100'
 - treba si vsak davat pozor na pouzitie s inymi programami, napr.: $ grep 'r.*t' /etc/passwd
   - napr. uvedeny prikaz dava neocakavany vysledok: $ grep 'r.*t /etc/passwd'
 - avsak pre porovnanie tieto dva prikazy:
   - prikaz 1: $ echo "I don't like unexpected bahavior in /etc/ directory." 
   - prikaz 2: $ echo 'I don't like unexpected bahavior in /etc/ directory.'

Dalsi priklad rozvijania specialnych znakov v BASHi: $ echo "Nemam ziadnu * v mojich cestach: $PATH" 
 - porovnat s prikazom: $ echo 'Nemam ziadnu * v mojich cestach: $PATH'

Prikazovy interpret BASH ma specialne premenne pre argumenty, napr. skript "ashow.sh":

#!/usr/bin/env bash
#
# jednoduchy BASH skript demonstruje specialne premenne
#
echo Vypisujem prvy argument: $1
echo Vypisujem druhy argument: $2
echo Vypisujem treti argument: $3
echo Vypisujem nazov skriptu: $0
echo Vypisujem process ID skriptu: $$
echo Vypisujem pocet odovzdanych argumentov: $#
echo Vypisujem vsetky argumenty: $@
#
# koniec skriptu
#

 - ulozime do suboru "ashow.sh" a nastavime prava, napr.: $ chmod u+rx ashow.sh
 - nasledne mozeme skript spustit: $ ./ashow.sh raz dva tri

Presmerovanie diagnostickych vypisov/vystupov:
 - Chybovy vypis/vystup mozeme presmerovat do standardneho vypisu/vystupu s: 2>&1
 - Opacny postup: 1>&2

Pozriet riadenie toku BASH skriptu, resp. rozhodovanie s:"if", "then", "else", "elif" "while", "until", "case".
 - zakladny rozcestnik $ man bash
 - dalsi uzitocny manual: $ man test 

Priklad na riadenie toku v BASH skripte s "if", vytvorime si skript "ifPriklad.sh":

#!/usr/bin/env bash
#
# jednoduchy BASH skript demonstruje riadenie toku s "if"
#
# testujeme obsah prveho argumentu:
if [ "$1" = ahoj ]
then
    echo 'Zadany argument bol ahoj.'
#
# testujeme pocet zadanych argumentov:
elif [ "$#" = 0  ]
then
    echo "Nezadal si ziaden argument."
#
# pokrocilejsie testovanie regularneho vyrazu (regexp):
elif [[ "$1" =~ a.*j  ]]
then
    echo "Skoro dobre, zadal si argument: $1"
#
# posledna moznost, ked nic ine nevyhovie podmienkam:
else
    echo "Sme vedla od slova ahoj, zadal si argument $1"
fi
#
echo "Koniec skriptu, exit code: $?"
#

Dalej doporucujem pozriet zaklady BASH skriptovania, napr. v knihe: https://www.root.cz/knihy/bash-ocima-bohdana-milara/
 - pokrocilejsie skriptovanie, napr. v knihe: https://tldp.org/LDP/abs/abs-guide.pdf
 - pripadne pozriet 11. kapitolu v knihe "How Linux Works by Brian Ward" ISBN-13: 9781718500402

Ako pomocou jazyka Awk vypisat deviaty stlpec z vypisu: $ ls -l | awk '{print $9}'

Pozriet dalsi program na spracovanie textu: $ man sed

Pozriet tematiku "BASH Subshell"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s prenosom suborov po sieti*

Ako spustit jednoduchy HTTP server (Python modul) v danom adresary: $ python3 -m http.server
 - standardne spusteny na TCP porte 8000, mozeme zmenit s : $ python3 -m http.server 5000
 - na TCP porty nizsie ako 1024 su potrebne prava "root", cize napr.: $ sudo python3 -m http.server 80
 - na starsich instalaciach sa da pouzit Python2 modul: $ python -m SimpleHTTPServer

Na transfer suborov pomocou prgramu "rsync", musi byt program na "oboch stranach"
 - pre Debian based systemy $ sudo apt install rsync
 - alebo pre Fedora Server: # dnf install rsync 

Zakladne pouzitie, skopirujeme 3 sobory s diagnostikou: $ rsync -v ifPriklad.sh casePriklad.sh ashow.sh 192.168.1.245:

Ako skopirovat vsetky adresare s nazvom "dirX" na stroj s DNS nazvom "ubu2.lab" do vzdiualeneho adresara "nas":
 - parameter "-a" umoznuje skopirovat nastavenia suborovych prav, nastavenie UID bitov a pod.
 - teda pouzijeme: $ rsync -va dir* ubu2.lab:nas
 - aby netrebalo zadavat SSH heslo, moze sa nahrat verejny kluc PKI: $ ssh-copy-id userXYZ@ubu2.lab
 - ked chceme transfer/zalohu len otestovat, pouzijeme parameter "-n": $ rsync -n -va dir* ubu2.lab:nas

POZOR, ked chceme v cieli vytvorit EXAKTNU kopiu lokalneho(ych) adresara(ov), ktora ZMAZE nove subory v cieli:
 - pouzijeme: $ rsync -va --delete dir* ubu2.lab:nas
 - diagnosticky parameter "-v" vypise, ktore subory v cieli boli vymazane

Ked chceme vykopirovat LEN obsah lokalneho adresara po sieti, dolezity znak "/": $ rsync -av dir1/ ubu2.lab:
Ked chceme vynechat subor, specifikujeme absolutnu cestu: $ rsync -av --exclude=dir1/junk.txt dir1 ubu2.lab:
Ked chceme prenos overit kontrolnym suctom, pouzijeme parameter "-c" alebo "--checksum"
Pozriet v "$ man 1 rsync" dalsie parametre ohladom zalohovania: "-b" a "--suffix=.old" a "-u" 

Ako obmedzit BW, napr. na 50MBytes/s (cca 400Mbit/s): rsync -a --bwlimit=50000 same_nuly.txt ubu2.lab: 
 - priklad ako vytvorit testovaci 1GiB subor: $ dd if=/dev/zero of=same_nuly.txt bs=1024 count=1M
  
*Dalej pozriet dokumentaciu a manualy k projektu "Samba File/Printer Sharing"*

*Praca s SSHFS*

Ako si pripojit vzdialny adresar cez SSH, napr.: $ sshfs userABC@ubu2.lab:/mnt/lvnas1 sshnas.d/
 - kombinovatelne s PKI auth (prihlasovanie verejnym klucom)
 - ako vykonat u-mount pripojeneho disku: $ fusermount -u sshnas.d/

*Praca s premennymi prostredia*

Premenne prostredia pre interpret BASH su definovane v "skrytych" suboroch: ".bash_profile" alebo ".profile"
 - priklad na definiciu premennej shellu: $ TEST=123 
 - priklad na definiciu premennej prostredia: $ export TESTENV=567 

Dolezite adresare na spustanie bin. aplikacii, v premennej $PATH: "/usr/local/bin" a "/usr/bin" a "/bin"
 - overime s prikazom: $ echo $PATH

V definicii promptu, teda v premennej $PS1 by sme sa mali vyhnut znakom: { } = & < >
 - dalsie detaily najdeme v manualy, v sekcii "PROMPTING" vid.: $ man bash

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s vyvojarskymi nastrojmi*

Jednoduchy priklad na kompilaciu zdrojoveho kodu v jazyku "C", vytvorime subor "pokus.c":

#include <stdio.h>

int main(void) {

    printf("Hello, World.\n");
}

- nasledne mozeme skompilovat, je potrebne nainstalovat dev. nastroje: # apt install build-essential
- na kompilaciu pouzijeme program "cc", teda "C Compiler": $ cc pokus.c
- vystupom bude spustitelny binarny subor "a.out": $ ./a.out
- pri kompilacii mozeme specifikovat nazov vystupneho suboru: $ cc -o pokus pokus.c 

Ako, ake zdielane kniznice ma nalinkovane dany program: $ sudo ldd /usr/bin/bash

Ako kompilovat zdrojove subory v kazyku "Java":
 - je potrebne nainstalovat vyvojarske nastroje: # apt install default-jdk-headless
 - vytvorime jednoduchy cvicny zdrojovy subor "pokus.java":

class MyFirstProgram {

    public static void main(String args[]){
        System.out.println("Hello World!");
    }
}

 - nasledne program skompilujeme do tzv. "byte code" formatu s priponou ".class": $ javac pokus.java
 - vznikne bytecode subor "MyFirstProgram.class", ktory spustime (bez pripony): $ java MyFirstProgram

Ako kompilovat a instalovat zdrojove baliky:
 - na test si vytvorime adresar "test_coreutils": $ mkdir test_coreutils 
 - do vytvoreneho adresara stiahneme zdrojovy balik: $ wget https://ftp.gnu.org/gnu/coreutils/coreutils-9.0.tar.gz  
 - rozbalime zdrojovy archiv: $ tar -xvzf coreutils-9.0.tar.gz
 - v rozbalenom adresary "coreutils-9.0" spustime konfiguracny "GNU Autoconf" (Shell) skript "configure"...
 - tento skript konfiguruje parametre kompilacie a naslednej instalacie...
 - skript spustime s parametrom cieloveho adresara kompilacie a instalacie: $ ./configure --prefix=$HOME/test_coreutils
 - nasledne po konfiguracii spustime kompilaciu: $ make
 - skompilovane programy a binarne objekty najdeme v adresary "coreutils-9.0/src/"
 - po kompilacii mozeme spustit rozsiahle overenie kompilacie: $ make check
 - po kompilacii mozeme "na sucho / dry run" spustit test instalacie: $ make -n install
 - po overeni mozeme spustit samotnu instalaciu: $ make install
 - po instalacii v adresary "test_coreutils" vzniknu adresare "bin", "libexec", "share"
 - na Debian-based distr. je nastroj na nastavenie parametrov ".deb" balickov "checkinstall": # apt install checkinstall
 - POZOR, na nasej testovacej instalacii mozeme spustit tvorbu balicka: # checkinstall make install
 - ^^^ uvedenym prikazom si mozeme rozbit system, tak doporucujem si na test VM spravit snapshot a opatrne...

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s kontajnermi, zaklady*

Instalacia najznamejsieho nastroja Docker nie je zlozita, ale ani trivialna, pouzil som postup napr.:

https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04

Ako otestovat, instalaciu Docker-a a jeho pripojenie na Docker Hub: $ docker run hello-world 
Na zakladne vytvorenie Docker kontajneru je potrebne definovat Docker file, s nazvom "Dockerfile":
- tento Docker file je vhodne umiestnit do oddeleneho adresara
- obsah suboru, moze byt podla jednoducheho prikladu, kedy definujeme kontajner Alpine Linux:

FROM alpine:latest
RUN apk add bash
CMD ["/bin/bash"]

- po ulozeni suboru, mozeme zostavit image nasledovne: $ docker build -t alpine_test1 .

Ako vypisat zakladne informacie o instalacii Docker a o systeme, na ktorom bezi: $ docker info
Ako vypisat vytvorene Docker image: $ docker images
Ako spustit kontajner (z image) a pripojit sa na jeho "konzolu": $ docker run -it alpine_test1
Ako sledovat aktualnu alokaciu zdrojov: $ docker stats

Ako vypisat zoznam aktivnych kontajnerov: $ docker ps
Ako vypisat aktivne aj neaktivne kontajnery: $ docker ps -a
Ako vypisat posledny vytvoreny kontajner: $ docker ps -l

Ako zmazat neaktivny kontajner: $ docker rm <ID/nazov>
Ako zmazat Docker image: $ docker rmi <ID/nazov image>

Ako hladat image na Docker Hub-e: $ docker search ubuntu
Ako stiahnut image z Docker Hub-u: $ docker pull ubuntu

Ako zastavit kontajner: $ docker stop <ID/nazov>
Ako spustit zastaveny kontajner: $ docker start <ID/nazov>
Ako sa pripojit na "kozolu" kontajneru, ktory bezi: $ docker attach <ID/nazov>
Ako sa odpojit od konzoly, v terminale za sebou skratky: "Ctrl+p a Ctrl+q"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Praca s nastrojom Git a platformou GitHub*

Vytvorime si pracovny adresar "git_ucenie", v ktorom inicializujeme *lokalny* Git repozitar: $ git init
 - aktualny stav repozitara overime s: $ git status
 - nastavime identitu uzivatela na pridavanie zmien: $ git config --global --edit
 - vytvorime cvicny subor, napr.: "poznamky.txt", do suboru napiseme "moja prva poznamka", subor ulozime
 - nasledne subor pridame do Staging Cache repozitara: $ git add poznamky.txt
 - overime s: $ git status
 - dalej pridame do *lokalneho* repo. novu zmenu, teda *commit* s popisom/spravou: 

$ git commit -m 'vytvoril som subor poznamky.txt a pridal 1. riadok'

 - dalej upravime subor "poznamky.txt", pridame riadok "dalsi riadok s poznamkou"
 - subor ulozime a overime stav *lokalneho* repo.: $ git status
 - podla vypisu je potrebne pridat upraveny subor do Staging Cache: $ git add poznamky.txt
 - jednoduchsie mozeme pridat vsetky subory v "root" adresary repozitara: $ git add .
 - aby sme sa vyhli pridavaniu suborov, ktore nechceme pridat do Staging Cache, vytvorime subor ".gitignore"
 - do suboru mozeme zapisat napr. riadok ".*" (bez uvodzoviek)
 - ak chceme odstranit subor z Cache, pouzijeme: $ git rm --cached <nazov_suboru>
 - pridame novu zmenu: $ git commit -m 'pridal som dalsi riadok'

Chceme napr. zmenit format zapisu poznamok, mozeme vytvorit vetvu, *branch*: $ git checkout -b 'novy_format'
 - v novej vetve mozeme napr. vytvorit subor "poznamky_novy_format.txt" a ten pridat do Cache a commitovat
 - ^^ avsak uz do novej vetvy/branch s nazvom "novy_format"
 - overime s: $ git status
 - potom sa mozeme prepinat medzi vetvami, napr. sa vratit hlavnej "master" vetvy: $ git checkout master
 - overime s: $ git status

Ked chceme replikovat repo. na vzdialeny server, napr. (hanbaty) GitHub:
- na platforme github.com si vytvorime uziv. ucet
- je potrebne vytvorit si autentifikacny Token, tzv. "Personal Access Token", podla odkazu:
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token

- dalej vytvorime repozitar s nazvom "git_ucenie", portal GiitHub nam vygeneruje zakladne prikazy.
- dalej si vytvorime vzdialeny pristup na repo., tzv. "Remote": $ git remote add origin https://github.com/UZIVATEL/git_ucenie.git 
- nasledne zosynchronizujeme kolakny repo. so vzdialenym repo.: $ git push -u origin master
- na autentifikaciu zadame svoje uziv. meno, ale namiesto hesla zadame vygenerovany PAT Token

Na ulahcenie prace si mozeme pridat do svojho $HOME adresara do suboru ".gitconfig" aliasy, napr.:

#
[alias]
    s = status
    co = checkout
    cob = checkout -b
    save = !git add -A && git commit -m 'Nic zasadne: len ukladam pripisany text'
    lg = !git log --pretty=format:\"%C(magenta)%h%Creset -%C(red)%d%Creset %s %C(dim green)(%cr) [%an]\" --abbrev-commit -30
    undo = reset HEAD~1 --mixed
    strom = !git log --graph --abbrev-commit --decorate --date=relative --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C$

Naslendne uz mozeme pouzivat napr. aliasy:

$ git s
$ git save
$ git lg
$ git strom

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
*Zaklady prace v terminale*

Ako vykonat upgrade balikov (Deb/Ubu): $ sudo apt update && sudo apt upgrade

Ako vymazat nepotrebne baliky (Deb/Ubu), po overeni funkcnosti: $ sudo apt autoclean && sudo apt autoremove 

 - pozriet distribucie MX Linux, Rocks Clusters, Pop!_OS, Lakka Gaming Distro

Prikazy ako "cd", alebo "umask" su Shell BuiltIn, nemaju manpage, preto: $ help cd
 - dalsi priklad :): $ help help
 - priklad: $ help if
 - priklad: $ help jobs

Ako prehladat manualove stranky: $ man -k "copy files"
 - podobne mozeme pouzit: $ apropos "copy files"

Ako nastavit velkost historie BASH interpretu (v RAM): $ export HISTSIZE=2000
 - pre subor ".bash_history" nastavime napr.: $ export HISTFILESIZE=2000
 
Ako nastavit do BASH historie, datum a cas: $ export HISTTIMEFORMAT="%d/%m/%y %T "
 - overime s prikazom: $ history

Ako spustit prikaz, aby sa neulozil do historie, prefixujeme ho medzerou: $  prikaz
 - napr. prikaz "$ ping linux.com" sa ulozi do historie, ale prikaz "$  ping linux.com" nie 
 - da sa nastavit premenna, aby hist. ignorovala duplicity a " ": $ export HISTCONTROL=ignoreboth  

Ako vypisat stromovu strukturu suborov, napr.: $ tree /home/student1 > strom.fs.student1.txt
 - je potrebne nainstalovat balicek "tree", dalsie informacie v: $ man tree

Ako vypisat (priblizne) podla velkosti adresare a subory: $ du -hd 1 | sort 

Ako vyfiltrovat MAC adresy z vypisu a ulozit ich zaroven do suboru: $ ip a s | grep ether | cut -d" " -f6 | tee mac-adresy.txt 

Ako porovnat dva subory s detailnejsim rozpisom: $ diff -c a b
 - dva subory mmozeme porovnat vedla seba: $ diff -y a b
 - dalsie info v: $ man diff

Ako vytvorit komprimovany (BZip2) archiv: $ tar -cvjf subory.tar.bz2 a.txt b.txt c.txt 
 - ekvivalent pre GNUzip kompresiu: $ tar -cvzf subory.tar.gz a.txt b.txt c.txt
 - mozeme kombinovat subory/adresare: $ tar -cvzf dalsie_subory.tgz dir1/ dir2/ a.txt b.txt
 - extrakcia do vopred vytvoreneho adresara: $ tar -xvjf subory.tar.bz2 -C zaloha.d/

Ako vytvorit adresarovu strukturu huerarchiu jednym prikazom: $ mkdir -p prvy/druhy/treti

Ako vypisat konf. subory, zmenene za posledny den: $ sudo find /etc -type f -mtime 0 -exec ls -l {} \;
 - zaloha suborov, zmenenych za poslednych 7 dni: $ sudo find /etc -type f -mtime -7 -exec cp {} /root/backup \;
 - aby sa "find" pytal, ci chceme napr. zmazat stare subory: $ find . -type f -mtime +30 -ok rm {} \;  
 - ^ pripadne mozeme najskor (30 dni stare) subory len VYPISAT: $ find . -type f -mtime +30 -print

Ako hladat subory podla nazvu, nova implementacia "mlocate": $ sudo apt install mlocate
 - databazu suborov aktualizujeme pomocou "cron" alebo rucne: $ sudo updatedb 
 - stav databazy overime s: $ mlocate -S
 - da sa spustat aj symlinkom, napr.: $ locate .bashrc
 - dalsie informacie: $ man mlocate

Ako hladat programom "find" bez rozlisenia A/a: $ find . -iname PriKlad.txt

V BASH-y sa tzv. "glob-y" volaju aj "Shell Meta Characters", napr. "*"

Prikaz najde, spocita adresare v "/etc", hlbka 3 adresarov s pravami "755": $ sudo find /etc/ -maxdepth 3 -type d -perm 755 | wc -l 

Ako vypisat subory s velkostou medzi 3G a 4G: $ find /home/nas/ -type f -size +3G -size -4G
 - da sa doplnit det. vypis do suboru: $ find /home/nas/ -type f -size +3G -size -4G -ls > zoznam.txt

Asociacia medzi suborovou strukturou a nazvom suboru sa nazyva tzv. "hardlink"
 - pocet asosiacii overime s: $ stat subor.txt
 - ako hladat hardlink-y podla cisla "inode" (index node): $ find . -inum 12345
 - pozor, hardlink nemoze opustit hranice suboroveho systemu
 - koncept hardlink je napr. uzitocny pre "nadradeny" adresar, oznaceny ".."

Ako naist a vypisat objekty s viac ako 1 hardlinkom: $ find /var/ -links +1 -ls

Ako presuvat subory len aktualnejsie alebo chybajuce subory: $ mv -u <zdroj> <ciel>

V adresary /home/student/ vytvori uzivatel "root" subor "a.txt", moze ho uzivatel "student" vymazat?

Prikaz najde "chybove" hlasky v Syslogu: $ grep -win error /var/log/syslog
 - param. "-w" hlada presne slovo, param. "-i" nerozlisuje A/a, param. "-n" vypise c. riadku 

Ako naist v kernel ring buffery "error" a vypisat 3 riadky pred a za nim: # dmesg | grep -C 3 error

Zaujimavost, ako vypisat citatelne znaky v aktualnom image RAM: $ sudo strings /dev/mem
 - dalsie informacie v "man mem" a v "man strings"

Ako vo Vim-e spravit undo: ":e!" , alebo "command-mode" stlacime "u"
 - vo Vim-e vlozime novy riadok s: "o"
 - ak chceme rychlo ulozit subor a ukoncit Vim, stlacime: "Shift+zz"
 - cisla riadkov zapneme s: ":set nu"
 - text oznacime v command mode s "V" + sipky, nasledne "y", potom vlozime pod kurzor s "p"
   - alebo mozeme vystrihnut s "dd"
 - na konkretne cislo riadka sa prepneme s: ":<cislo>"
 - dva sposoby ako otvorit 2 subory: "vim -o a.txt b.txt" alebo "vim -d a.txt b.txt"
   - medzi oknami sa prepiname s "Ctrl+ww"  

Ako v realnom case sledovat prihlasovanie uzivatelov: $ sudo tail -f /var/log/auth.log

Ako vytvorit uzivatela, ktoreho ucet exspiruje v urcity datum: # useradd -e 2022-2-13 u2
 - prikazom "chage" mozeme zadefinovat, kedy exspiruje heslo uzivatela

Ako pridat uzivatela "u1" do skupiny "sudo": # usermod -G sudo u1
 - uziv. skupina sa neda vymazat, pokial sluzi ako primarna skupina uzivatela

POZOR, ako vymazat uzivatela "u1" aj s jeho "home" adresarom: $ sudo userdel -r u1

Ako premenovat uziv. skupinu: $ sudo groupmod -n <novy_nazov> <povodna_skupina>

Jednoduchym prikazom "w" vypiseme zakladny stav systemu a prihlasenych uzivatelov: $ w
 - historicky zaznam prihlasovania uzivatelov vypiseme napr. s: $ sudo last
   - mozeme specifikovat aj konkretneho uzivatela "u1": $ sudo last u1

Nastroj "nstat" doplna sietovu diagnostiku kernelu, je z balika "iproute2"
 - dalsie informacie "man ncast", je dobre spustat takto: $ nastat -s

Ako overit, ci kernel kvoli teplote nepodtaktoval jadra CPU: $ sudo dmesg | grep "cpu clock" 

Ak nastavime na subor prava "$ chmod 000 subor.txt", moze ho niekto citat/upravovat?

Hesla ulozene (Ubu 20.04) v subore "/etc/shadow" su vo formate: "$id$salt$hash"
 - napr. identifikator (id) "6" znamena "SHA-512"

Ako vypisat atriburty (nie prava) konkretneho suboru: $ lsattr subor.txt
 - vyznam atributov najdeme napr. v: $ man chattr
 - napr. mozeme na subor nastavit tzv. "no append" atribut: $ chattr +a subor.txt
 - napr. mozeme nastavit tzv. "immutable" atribut, ktory "zmrazi" upravy: $ chattr +i subor.txt
 - atributy mozeme nastavit aj rekurzivne, pre obsah adresara: $ sudo chattr -R dir1/

Ako nastavit "SET UID bit", absolutny mod "$ chmod 4XXX a.bin", relativny mod "chmod u+s a.bin" 
 - overime napr. prikazom: $ stat a.bin
 - program/skript je spustany s pravami vlastnika, nie s pravami zadavatela prikazu
   - typicky priklad napr.: $ cat /etc/shadow

Ako naist subory, ktore maju "aspon" prava "4000": $ find /usr/bin/ -perm -4000 -ls

Ako nastavit "SET GID bit", absolutny mod "$ chmod 2XXX dir1/", relativny mod "chmod g+s dir1/"
 - subory vytvorene v adresary s "SGID" bitom budu mat vlastnika podla skupiny adresara "dir1/"
 - uzitocne pre vytvaranie zdielanych adresarov
 - ako priklad mozeme vytvorit dedikovany adresar pre dvoch vyvojarov:

 # adduser dev1                       <-- vytvorime uzivatelov   
 # adduser dev2
 # usermod -aG developers dev1        <-- vytvorime skupinu a zaradime uzivatelov
 # usermod -aG developers dev2
 # mkdir /repo.d                      <-- vytvorime zdielany adresar
 # chown dev1:developers /repo.d/     <-- nastavime vlastnika/skupinu
 # chmod o-rx /repo.d/                <-- nastavome prava
 # chmod g+s /repo.d/                 <-- nastavime "SGID" bit

 - nasledne overime tak, ze uziv. "dev1" vytvori subor: $ touch program.c
 - so spravnym nastavenim ma editovaci pristup aj uzivatel "dev2"

Ako nastavit "Sticky bit", absolutny mod "$ chmod 1XXX dir1/", relativny mod "chmod o+t dir1/"
 - zmena zabezpeci, ze sa v (zdielanom) adresary na novy subor "nalepia" prava tvorcu, nie adresara
 - typicky priklad je systemovy adresar "/tmp", aby si v nom zuivatelia navzajom nemazali subory

Ako nastavovat prava suborov/adresarov napr. v skripte: $ chmod ug=rw,o=r subor.txt
 - ako nastavit prava, podla nejakeho vzoroveho suboru: $ chmod --reference=prvy.txt druhy.txt

Ako hromadne nastavovat prava suborov, napr.: $ find $HOME -type f -exec chmod 640 {} \;

Ako nastavit predvolene prava na vytvorene subory na "0640": $ umask 0026 subor.txt
 - overime s "$ ls -l subor.txt" alebo "$ stat subor.txt"
 - je dobre si uvedomit, ze pri prikaze "umask" odpocitavame od 0666, teda (0666 - 0026) = 0640
 - pre perzistentne nastavenie vlozime do suborov ".profile" alebo ".bashrc" riadok "umask 0026" 

Pozriet nastroje eBPF zo sady "BCC Tools" a "BPF trace tools", napr: # apt install bpfcc-tools
 - napr.: "opensnoop-bpfcc", "execsnoop-bpfcc", "tcplife-bpfcc", "ext4slower-bpfcc", "biosnoop-bpfcc"
 - ohladom disk-IO je este uzitocny nastroj "biotop-bpfcc"
 - dalsie info (kto vie do kedy online): https://github.com/iovisor/bcc/blob/master/INSTALL.md
 - dalsie nastroje od Brendana Gregga: https://brendangregg.com/linuxperf.html

Typy procesov v operacnom systeme GNU/Linux: Parent, Child, Daemon, Zombie (defunct), Orphan

Ako vypisat 3 iteracie programu "top" s oneskorenim 2 s. do suboru: $ top -d 2 -n 3 -b > stav.txt  
 
Klavesy v "top": "d" oneskorenie, "e" jednotky RAM, "M" podla RAM, "P" podla CPU, "1" zob. CPU jadra

Ako spustit proces/program, aby ho nezabilo zatvorenie/odpojenie BASH session: $ nohup <prikaz> &

Zakladne programy na spravu procesov: "ps", "pgrep", "pstree", "pkill", "pidof", "kill", "killall"
 - dalsie informacie v: $ man <nazov>

Ako v (hanbatom) MacOS Big Sur zistit presny typ CPU: $ sysctl -a | grep brand

Ako zmenit MAC adresu na Eth. rozhrani: $ sudo ip link set dev ens33 address 12:34:56:78:9a:bc

Ako zistit, ake DNS servery pouzivaju distribucie so SystemD: $ systemd-resolve --status
 - alebo alternativne: $ resolvectl status
 
Ako zadat, uzivatelov, ktory maju povoleny SSH login, do suboru "/etc/ssh/sshd_config" vlozime:

"AllowUsers student1 user1 developer1" 

 - nasledne upravu ulozime a restartujeme SSH server: $ sudo systemctl restart ssh
 - overime s: $ sudo systemctl status ssh

Ako overit, ci sa proces/program spusti po restarte systemu: $ sudo systemctl is-enabled <nazov>
 - napr.: $ sudo systemctl is-enabled ssh 

Ako na jednoduchu zalohu adresara "/etc" pomocou "rsync": # rsync -av /etc/ /media/USBdisk1/zaloha/

Tri divne sposoby, ako generovat 16 znakove heslo (bez instalacie dalsich programov):

$ openssl rand -base64 12
$ head /dev/urandom | base64 | cut -b 1-16
$ echo $(head /dev/urandom | shasum | base64 | cut -b 1-11).$(date +%Y)

Ako vytvorit/stiahnut kompletnu kopiu/mirror nejakeho webu, pouzijeme program "wget":

$ wget --mirror --convert-links --adjust-extension --page-requisites --no-parent http://example.com
 - alebo skratene: $ wget -mkEpnp http://example.com

Ako nainstalovat zakladne vyvojarske nastroje: $ sudo apt install build-essential
 - RedHat-based distribucie (Fedora/CentOS) napr.: $ sudo dnf group install "Development Tools" 

Poznamka, adresar "/opt" znamena "Optional Software", sluzi zvycajne na kompilaciu programov
 - napr. kompilacia programu "ProFTPD", pouzijeme nastavenie: $ ./configure --prefix=/opt/proftpd

Ako prehladavat lokalnu DPKG databazu (Debu/Ubu): $ dpkg-query -l | grep ssh
 - dalej napr. mozeme vypisat obsah balicka: $ dpkg -L openssh-server

Ako zistit, do akeho balika patri program "ls", najskor "$ which ls", nasledne: $ dpkg -L /bin/ls
 - znova mozeme prezriet obsah balika: $ dpkg -L coreutils | less
 
Ako overit obsah lokalnej "APT cache" (Deb/Ubu): $ ls -l /var/cache/apt/archives/
 - aka je jej velkost: $ sudo du -sh /var/cache/apt/archives/ 
 - mozeme vycistit pomocou: $ sudo apt clean

Ako zistit, ake su nainstalovane baliky: $ apt list --installed

Ako vypisat info. o HW pod nainstalovanym systemom: $ sudo lshw > hw.txt
 - mozeme vypisat JSON resp. HTML format: "# lshw -json > hw.json" resp. "# lshw -html > hw.html"
 - uspornejsi vypis ziskame s: $ sudo lshw -short 

Podrobne informacie o CPU ziskame s: $ lscpu
 - dalej ziskame informacie o RAM: $ sudo dmidecode -t memory
 - informacie o velkosti modulov a max. kapacite: $ sudo dmidecode -t memory | grep -i size
 - podobne ziskame informacie o zakladnej doske: $ sudo dmidecode -t baseboard
 - dalsie moznosti zistime s: $ sudo dmidecode -t
 - informacie o zberniciach PCI a USB ziskame s  "$ lscpi" resp. "$ lsusb"
 - informacie o HDD/SSD: $ sudo lshw -C disk 
 - ako ziskat detailne informacie o konkretnom SATA zariadeni: $ sudo hdparm -I /dev/sda
 - POZOR, test rychlosti citania SATA, bez cache (raw I/O): $ sudo hdparm -t --direct /dev/sda
 - informacie o Wireless zariadeniahc ziskame s: $ sudo iw list | less
 - ako obvykle dalsie informacie: $ man <lshw/lscpu/dmidecode/lspci/lsusb/hdparm/iw>

Ako zistit kolko trvalo bootovanie pomocou "SystemD": $ systemd-analyze
 - ak je to mozne, snaha "SystemD" je spustat jednotlive procesy/sluzby paralelne
 - da sa detailne vypisat, na com sa travilo najviac casu: $ systemd-analyze blame

Ako vypisat len "EXT4-FS" mount-pointy: $ mount -l -t ext4
 - dalsi priklad pre VFAT-FS, ktory byva na USB "klucoch": $ mount -l -t vfat

Ako vytvorit bitovu kopiu USB disku: # dd status=progress if=/dev/sdb of=/home/user1/usb-backup.img 
 - nasledne obnova z image-file: # dd status=progress if=/home/user1/usb-backup.img of=/dev/sdb

Ako vytvorit premennu prostredia (Env. var.) pre cely system, upravime subor "/etc/bash.bashrc"
 - alternativne mozeme pouzit subor "/etc/profile"

Ako zadefinovat konstantu: $ declare -r nemenna="/var/log"

Ako v BASH skripte zadefinovat lokalnu (len vo funkcii) premennu: "local var1=len_vo_funkcii"

Ako ulozit vystup zlozeneho prikazu do premennej: $ output="$(ps -ef | grep ssh)"
 - nasledne vypiseme (so zachovanym formatovanim) ako retazec/string: $ echo "$output" 

Ako v BASH skripte testujeme, ze premenna obsahuje substring: if [[ "$str1" == *[lL]inux"* ]]

Testovanie BASH premennej s logickymi operatormi: if [[ $vek -ge 0 ]] && [[ $vek -le 18 ]]

Priklad na cvicny input error handling (osetrenie chybneho vstupu) v jazyku BASH:

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#!/bin/bash
#
# Cvicny skript ocakava cele cislo v ramci vymedzenych hodnot, 17.2.2022 by vlkv
#
vek=-1
set -e
echo

while [[ $vek == -1 ]]; do
    read -p "Zadajte vek (rozsah 0 az 120): " vek
        if [[ $vek -le -1 ]] || [[ $vek -ge 120 ]] || ! [[ $vek =~ ^[1-9][0-9]*$ ]]; then
            echo
            echo "CHYBA: Zadany vek \"$vek\" je mimo povolenych hodnot"
            vek=-1
        fi
done

echo "Zadali ste vek $vek roky/rokov."

# koniec skriptu
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Priklad nacita vo "for" slucke hodnoty z .txt suboru do premennej $ip:

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#!/bin/bash
for ip in $(cat /home/dev1/ip_adresy.txt)
do
    echo "Nacital som zo suboru IP adresu: $ip"
    sleep 1
done

# koniec skriptu
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Ako vytvorit skript s jednoduchym "select" menu v jazyku BASH:

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#!/bin/bash
#
#priklad na menu selection v jazyku BASH
echo
echo "Zakladna administraciu systemu:"
echo
PS3="Zvolte moznost (Enter vypise moznosti): "
select ITEM in "Pridaj uzivatela" "Vypis procesy" "Zabi proces" "Nainstaluj program" "Koniec"
do

	if [[ $REPLY -eq 1 ]]
	then
		read -p "Zadajte uzivatelske meno: " username
		buffer="$(grep -w $username /etc/passwd)"
		if [[ -n "$buffer"  ]]
		then
			echo "Uzivatel \"$username\" uz existuje"
		else
			sudo adduser $username
			if [[ $? -eq 0 ]]
			then
				echo "Uzivatel \"$username\" uspesne vytvoreny."
				tail -n 1 /etc/passwd
			else
				echo "Nastala chyba pri vytvarani uzvatela \"$username\""
			fi
		fi

	elif [[ $REPLY -eq 2 ]]
	then
		echo "Vypisujem vsetky procesy..."
		sleep 1
		ps -ef

        elif [[ $REPLY -eq 3 ]]
	then
		read -p "Zadajte nazov procesu: " proces
		pkill $proces

	elif [[ $REPLY -eq 4 ]]
	then
		read -p "Zadajte nazov balika: " balik
		sudo apt update && sudo apt install $balik

	elif [[ $REPLY -eq 5 ]]
	then
		echo "Koniec administracie."
		sleep 1
		exit

        else
		echo "Neplatna volba."
        fi
done

#koniec skriptu
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Jednoduchy priklad na hladanie substringu zo systemoveho vypisu:

#!/bin/bash
#
vystup="$(ping -f -i 0.5 -c 3 $1)"
#echo "$vystup"

if [[ "$vystup" == *"100% packet loss"*  ]]
then
        echo "Internetova konektiva na $1 je nedostupna."
else
        echo "Konektiva (ako tak) funguje."
fi

# koniec skpritu
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

*Pokracovanie prace s Docker-om*

Jednoduche web prostredie na ucenie/testovanie Docker-u: https://labs.play-with-docker.com/
 - dalsie informacie: https://www.docker.com/play-with-docker

Priklad ako spustit v "sandboxe" web server "nginx": $ docker container run -d -it nginx

Pre pomoc s CLI, staci zadat prikaz bez parametrov, napr.: $ docker container

Priklad ako vytvorit zmenu v Docker image a commitovat ju:
 $ docker commit -m "pridany nmap" -a "Jan Novak" <cont-ID> <hub-repoID>/moje-ubu:latest 

 - nasledne overime s: $ docker image ls
 - mozeme napr. z noveho image spustit container s: $ docker container run -it ddnovak/moje-ubu

POZOR, prikaz vymaze *vsetky nebeziace* kontajnery: $ docker container rm $(docker container ls -a -q)
 - pripadne, na VLASTNE RIZIKO, mozeme spustit s paramentrom "rm -f"

Ako spustit testovaci webserver v kontajnery s nazvom "moj_lab" (vonkajsi port je TCP/8080):

$ docker container run -d -p 8080:80 --name=moj_lab nginx

 - overime s: $ docker ps
 - nasledne otestujeme pripojenie s browserom, alebo napr. $ curl localhost:8080
 - dalsie infromacie: $ docker container run --help
 - alternativne, image s web serverom Apache2: "httpd"

Ako vypisat otvorene TCP porty kontajnera: $ docker container port <contID/contNAME>
Ako vypisat logy z kontajnera (napr. server nginx): $ docker container logs <contID/contNAME>
 - sledovanie v realnom case, parameter: "logs -f"

Ako sledovat zdroje konkretneho kontajnera: $ docker container stats <contID/contNAME>
Ako vypisat detailne informacie o kontajnery: $ docker container inspect <contID/contNAME>

Ako spustit kontajner, hned s prikazovym riadkom: 

$ docker container run --name=ubu-con1 -it ubuntu
 - alebo, spustime interaktivny BASH na uz vytvorenom kontajnery: $ docker exec -it ubu-con1 bash 
 - alebo, spustime (zastaveny) kontajner v interaktivnom mode: $ docker start -i ubu-con1

Ako vypisat kolko miesta na disku zaberaju kontajnery: $ docker ps -as

Ako vytvorit perzistentne ulozisko pre kontajner "Docker Volume": $ docker volume create <nazov>
 - overime s $ docker volume ls
 - dalsie informacie: $ docker volume --help

Ako vytvorit "nginx" kontajner s namapovanyn volume:

$ docker run -d --name moja_web_app -p 80:80 -v <nazov_vol>:/usr/share/nginx/html nginx
 
- mozeme napr. manipulovat s obsahom "web root" adresara, teda: /var/lib/docker/volumes/mojvol/_data/
- priklad: $ sudo cp /etc/services /var/lib/docker/volumes/mojvol/_data/index.html
- overime napr. s: $ curl localhost:80

Poznamka, ak chceme vymazat Docker image, treba nasjkor pomazat z neho vytvorene kontajnery

POZOR, automaticky nastroj na cistenie tzv. "dangling" Docker images: $ docker system prune
 - dalsie informacie: $ docker system prune --help
 - celkom uzitocna diagnostika zabrateho miesta: $ docker system df

Nastroj na ochranu integrity suborov a adresarov "AIDE", instalacia: $ sudp apt install aide
 - instalacia na Fedora Server: $ sudo dnf install aide
 - dalsie informacie: https://aide.github.io/
 - vypiseme verziu a skompilovane moduly: $ aide -v
 - dalej mozeme vypisat moznosti a parametre: $ aide --help
 - konfiguracny subor je ulozeny v "/etc/aide/aide.conf"
 - inicializujeme "AIDE": $ sudo aideinit
 - inicializacia Fedora Server: $ sudo aide -i 
 - prikaz bezi nejaku dobu a vytvori (na Ubu) databazu signatur v: "/var/lib/aide/aide.db.new"
 - databa za Fedora Server: "/var/lib/aide/aide.db.new.gz"
 - dalej sa venujem "AIDE" na Ubuntu:
 - po vytvoreni DB je potrebne nahradit povodnu DB novou: $ sudo mv aide.db.new aide.db
 - na test mozeme spravit napr. zmeny v adresary "/root" alebo pridat uzivatela: $ sudo useradd ...
 - overime zmeny: $ sudo aide -c /var/lib/aide/aide.conf.autogenerated --check > aide.report.txt
 - nasledne pozrieme zmeny: $ sudo less aide.report.txt
 - je vhodne znova aktualizovat DB: $ sudo aide -c /var/lib/aide/aide.conf.autogenerated --update
 - dalej potrebna nahrada: $ sudo mv aide.db.new aide.db
 - vykonane zmeny v konfiguraci "/etc/aide/aide.conf" treba: $ sudo update-aide.conf
 - priklad zmeny "SHA256", riadok "Checksums = sha256+sha512+rmd160+haval+gost+crc32+tiger"
   - zmenime na "Checksums = sha256" cim dosiahneme zrychlenie, pokial nam postacuje len "SHA256"
   - mozeme nastavit ignorovanie niektorych adresarov/suborov, do konf. pridame: "!/var/lib/aide/.*"  
 - a nasledne inicializujeme s novou databazou: $ sudo aideinit
 - dalej je mozne vytvorit si vlastny config a vlastne pravidla, navody exsituju ;-)

Na overenie bezpecnosti hesla, mozeme pouzit nastroj "John the Ripper"
 - instalacia na Ubu/Deb: $ sudo apt install john
 - zlucime "/etc/passwd" a "/etc/shadow": $ sudo unshadow /etc/passwd /etc/shadow > unshadow.out.txt
 - na test spustime jednoduchy "single mode": $ sudo john -single unshadow.out.txt
 - overime s: $ sudo john --show unshadow.out.txt
 - vysledok pozrieme ulozeny v: $ sudo less /root/.john/john.pot
 - slovnikovy utok: $ sudo john --wordlist=/usr/share/john/password.lst --rule unshadow.out.txt
   - stlacenim napr. "medzernika" ziskame stav priebehu
   - stlacenim "Ctrl+c" alebo "q" prerusime prelamovanie, ale nestratime priebeh
   - priebezne vysledky ziskame s: $ sudo john --show unshadow.out.txt
   - prelamovanie mozeme obnovit s: $ sudo john -restore

Politiku systemovyh hesiel najdeme v subore "/etc/login.defs"
 - dalsie informacie v: $ man login.defs

Ako nastavit cas expiracie hesla na 30 dni: $ sudo chage -M 30 <uzivatel>
 - overime s: $ sudo chage -l <uzivatel>

Dalsie politiky hesla, ako napr. zlozitost spravuju "PAM - Pluggable Authentification Modules"
 - treba instalovat balik: $ sudo apt install libpam-pwquality
 - konfiguracia v subore "/etc/pam.d/common-password"
 - na upravu politiky pridame do riadku dalsie atributy: "password requisite pam_pwquality.so retry=3"
 - "minlen=10 difok=3 ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1" kde jednotlive atributy znamenaju:
 - "retry=" kolko krat sa login process spyta na heslo 
 - "minlen=" minimalna dzlka hesla
 - "difok=" minimalny pocet znakov odlisnych od povodneho hesla
 - "ucredit=" atribut s "-1" vyzaduje aspon jedno velke pismeno (upper case)
 - "lcredit=" atribut s "-1" vyzaduje aspon jedno male pismeno (lower cace)
 - "dcredit=" atribut s "-1" vyzaduje aspon jeden numericky znak (numeric character)
 - "ocredit=" atribut s "-1" vyzaduje aspon jeden specialny znak (special character)
 - na "RedHat-based" distribuciach sa pouziva konf. subor: "/etc/pam.d/system-auth"

Ako vytvorit sifrovanu particiu na HDD/SSD, potrebne nainstalovat: $ sudo apt install cryptsetup
 - disk, ktory chceme sifrovat, musi byt "unmounted"
 - dalej spustime sifrovanie a nastavime kluc/heslo: $ sudo cryptsetup -y -v luksFormat /dev/sdX
 - nasledne vytvorime mapovacie zariadenie: $ sudo cryptsetup luksOpen /dev/sdb crypt1
   - vytvori sa symbolicky link "/dev/mapper/crypt1 -> /dev/dm-X"
 - overime s: $ sudo cryptsetup status crypt1
 - po overeni vytvorime particu/FS, napr. Ext4: $ sudo mkfs.ext4 /dev/mapper/crypt1
 - dalej mozeme "namountovat" novu particiu na adresar: $ sudo mount /dev/mapper/crypt1 /mnt/crypt1/
 - volitelne nastavime vlastnika/prava, napr.: $ sudo chown user1:user1 /mnt/crypt1/
 - po ukonceni prace: "$ sudo umount /mnt/crypt1" nasledne: "$ sudo cryptsetup luksClose crypt1"
 - nova uloha: $ sudo cryptsetup luksOpen /dev/sdb crypt1
   - nasledne: $ sudo mount /dev/mapper/crypt1 /mnt/crypt1/

Relacia vytvorena prikazom "sudo" ma pristupove prava v "cache" presne 15 min.
 - cache sa da zmanzat s: $ sudo -k
 - toto nastavenie mozeme zmenit, napr. na 10 min., otvorime konfiguraciu "sudoers": $ sudo visudo
 - nasledne riadok "Defaults env_reset" upravime na: "Defaults env_reset, timestamp_timeout=10" 
 - mozeme nadefinovat, povolene prikazy, dopiseme: "user1  ALL=(root)      /usr/bin/ls,/usr/bin/cat"
 - dalsie informacie 

Poznamka: v oblasti Steganografie sa pouziva nastroj "steghide": $ sudo apt install steghide
 - dalsie informacie: https://en.wikipedia.org/wiki/Steganography
 - informacie o programe: $ man steghide
